---
title: "spatial error model"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

Spatial lag model: i believe this is very similar to what we've already done with temporal lag.... the dependent variable in neighboring areas is included - use this when the value of variable in one county directly affects the value in another county (we do not necessarily believe that the health of a county DIRECTLY impacts the health of neighboring county)

Spatial error model: capture spatial autocorr in the error term - use this when omitted spatially correlated vars cause dependence (perhaps by ignoring the presence of highways, commuting zones, etc we are introducing spatial dependence which we can remove using a spatial error model)

Sparks and Sparks tested both spatial lag and spatial error models and concluded that spatial error models better described mortality data - therefore, that's what we'll use too. i see no need to double check this since we do not believe that counties directly affect their neighbors, as we would assume with spatial lag)

-   In non spatial models we used the following syntax to specify random intercepts and slopes: (1\|GEOID) is a random intercept; each fips's reg line is shifted up/down randomly with mean 0

-   (1+t\|GEOID) includes a random slope for time; the effect of time differs randomly from fips to fips

It appears that in the splm package, should instead use:

-   model = ("within", "random", "pooling") to add random effects

-   effect = c("individual", "time", "twoways") to tell the function where the random effect belongs

-   effect = "individual" -\> spatial fixed effects

-   effect = "time" -\> time fixed effects

The help page for this particular function is not useful. Instead, I am referencing this document: https://www.insee.fr/en/statistiques/fichier/3635545/imet131-k-chapitre-7.pdf

From this document we see that:

"the user may choose between pooling for

a pooled data model, within for a fixed-effect model or random for a randomised model. It

is also possible to define whether the effects relate to individuals or/and periods using the op-

tion effects that can be established as equal to individual, time or twoways. We can also

choose whether the specification includes spatial terms: lag=T in the SAR model, or lag=F in all

other cases. Lastly, it is possible to choose the nature of the specification in the random effects

model: spatial.error="b"for a Baltagi specification, spatial.error="kkp"for the KKP-style

specification (Kapoor et al. 2007) or spatial.error="none" in all other cases."

Based on this, in order to match the models in lmer that we were using previously, using the spml function, we will need model = "random", effect = "twoways", lag = FALSE, and spatial.error = "none"

Switching spatial.error = "none" should be the only change from the nonspatial to the spatial

I will test this on a subset of states so things run quickly

```{r}

```

```{r}

library(tidyverse)
library(splines)
library(splm)

# potential formulas that i'd like to test (with and without spatial error)

fm = rate_d1 ~ ft + rate_d0 + migterm
fnom = rate_d1 ~ ft + rate_d0 
fff2 = rate_d1 ~ ft + ns(rate_d0, df = 2) + ns(migterm, df = 2) + (1 + t | GEOID) 
fff4 = rate_d1 ~ ft + ns(rate_d0, df = 4) + ns(migterm, df = 4) # + (1 + t | GEOID) 
fff3 = rate_d1 ~ ft + ns(rate_d0, df = 3) + ns(migterm, df = 3) # + (1 + t | GEOID) 
fff5 = rate_d1 ~ ft + ns(rate_d0, df = 5) + ns(migterm, df = 5) # + (1 + t | GEOID) 
fff2_nomig = rate_d1 ~ ft + ns(rate_d0, df = 2) # + (1 + t | GEOID) 
fff4_nomig = rate_d1 ~ ft + ns(rate_d0, df = 4) # + (1 + t | GEOID) 
fff3_nomig = rate_d1 ~ ft + ns(rate_d0, df = 3) # + (1 + t | GEOID) 
fff5_nomig = rate_d1 ~ ft + ns(rate_d0, df = 5) # + (1 + t | GEOID) 


# get a subset of data 
load("data_processed/migterm_imp.RData")

cp = tidycensus::get_acs(geography = "county", year = 2019, variables = c(tpop = "B01003_001"), survey = "acs5", output = "wide", geometry = TRUE)

cpmig = merge(cp, migterm_imp, by.x = "GEOID", by.y = "destid", all.y = TRUE)


cpmig = cpmig %>% 
 arrange(year) %>% 
 group_by(GEOID) %>% 
 mutate(t = row_number())

cpmig$ft = as.factor(cpmig$t)


cpbal = cpmig %>% group_by(GEOID) %>% 
  filter(statecode %in% c(55,27,17,19)) %>% #wi, mn, il, ia
  select(rate_d1, ft, rate_d0, migterm, GEOID, geometry, ft,t)



spsub= cpbal %>% select(GEOID, geometry) %>% distinct()
queen = spdep::poly2nb(spsub, row.names = "GEOID", queen = T)
queenw = spdep::nb2listw(queen, style = "W", zero.policy = TRUE)

cpbal = plm::pdata.frame(cpbal, index = c("GEOID", "ft"))
cpbal$ft = factor(cpbal$ft, levels = c(1:9))

#should follow similar proceedure for spatial as for nonspatial 
# compare with and without spatial, with and without migterm, with and without splines 

#####################################################################

# linear mixed effect model with no spatial component via maximum likelihood 
fff0 = rate_d1 ~ ft + ns(rate_d0, df = 2) + ns(migterm, df = 2) + (0 + t| GEOID) 
fff1 = rate_d1 ~ ft + ns(rate_d0, df = 2) + ns(migterm, df = 2) + (1 + t| GEOID) 
rfff0 = lme4::lmer(formula = fff0, data = cpbal)
rfff1 = lme4::lmer(formula= fff1, data = cpbal) #this fails to converge.... 
# not sure what the difference is between 0 and 1 



# spatial panel mixed effect model via maximum likelihood  
fff2 = rate_d1 ~ ft + ns(rate_d0, df = 2) + ns(migterm, df = 2) #+ (1 + t | GEOID) 
sfff2 = splm::spml(formula = fff2, data =cpbal, model = "random", effect = "individual", listw = queenw, lag = FALSE, spatial.error= "none")
summary(sfff2)

# regular model with what i think are random effects using the spgm function 
```

```{r}
# so (1 + t | GEOID) should become 
# model = "random" and effect = "twoways" 
# documentation says: "it is advisable to employ a within transformation whenever individual effects cannot be ruled out" 
# we want to include effects for geoid...so then within seems like a logical choice to include 

fm = rate_d1 ~ ft + rate_d0 + migterm
fnom = rate_d1 ~ ft + rate_d0 
fff2 = rate_d1 ~ ft + ns(rate_d0, df = 2) + ns(migterm, df = 2) # + (1 + t | GEOID) 
fff4 = rate_d1 ~ ft + ns(rate_d0, df = 4) + ns(migterm, df = 4) # + (1 + t | GEOID) 
fff3 = rate_d1 ~ ft + ns(rate_d0, df = 3) + ns(migterm, df = 3) # + (1 + t | GEOID) 
fff5 = rate_d1 ~ ft + ns(rate_d0, df = 5) + ns(migterm, df = 5) # + (1 + t | GEOID) 
fff2_nomig = rate_d1 ~ ft + ns(rate_d0, df = 2) # + (1 + t | GEOID) 
fff4_nomig = rate_d1 ~ ft + ns(rate_d0, df = 4) # + (1 + t | GEOID) 
fff3_nomig = rate_d1 ~ ft + ns(rate_d0, df = 3) # + (1 + t | GEOID) 
fff5_nomig = rate_d1 ~ ft + ns(rate_d0, df = 5) # + (1 + t | GEOID) 


spatialreg::errorsarlm(formula = fff2, data = mwi_bal, listw = queenw, quiet = T)

#without spatial stuff 
nospat_fm = splm::spml(formula = fm, data =mwi_bal, model = "random", 
                       listw = queenw, lag = TRUE, spatial.error= "none")
nospat_fnom = splm::spml(formula = fnom, data =mwi_bal, model = "random", 
                       listw = queenw, lag = TRUE, spatial.error= "none")
nospat_fff2 = splm::spml(formula = fff2, data =mwi_bal, model = "random", effect = "twoways", 
                       listw = queenw, lag = TRUE, spatial.error= "none")
nospat_fff3 = splm::spml(formula = fff3, data =mwi_bal, model = "random", effect = "twoways", 
                         listw = queenw, lag = TRUE, spatial.error= "none")
nospat_fff4 = splm::spml(formula = fff4, data =mwi_bal, model = "random", effect = "twoways", 
                         listw = queenw, lag = TRUE, spatial.error= "none")
nospat_fff5 = splm::spml(formula = fff5, data =mwi_bal, model = "random", effect = "twoways", 
                         listw = queenw, lag = TRUE, spatial.error= "none")
nospat_fff2_nomig = splm::spml(formula = fff2_nomig, data =mwi_bal, model = "random", effect = "twoways", 
                         listw = queenw, lag = TRUE, spatial.error= "none")
nospat_fff3_nomig = splm::spml(formula = fff3_nomig, data =mwi_bal, model = "random", effect = "twoways", 
                         listw = queenw, lag = TRUE, spatial.error= "none")
nospat_fff4_nomig = splm::spml(formula = fff4_nomig, data =mwi_bal, model = "random", effect = "twoways", 
                         listw = queenw, lag = TRUE, spatial.error= "none")
nospat_fff5_nomig = splm::spml(formula = fff5_nomig, data =mwi_bal, model = "random", effect = "twoways", 
                         listw = queenw, lag = TRUE, spatial.error= "none")


# with spatial stuff 

spat_fm = splm::spml(formula = fm, data =mwi_bal, model = "error", effects ="tpfe",  
                        w = queenw, lag = TRUE)
spat_fnom = splm::spml(formula = fnom, data =mwi_bal, model = "error", effects ="tpfe",  
                         w = queenw, lag = TRUE)
spat_fff2 = splm::spml(formula = fff2, data =mwi_bal, model = "error", effects ="tpfe",  
                         w = queenw, lag = TRUE)
spat_fff3 = splm::spml(formula = fff3, data =mwi_bal, model = "error", effects ="tpfe",  
                         w = queenw, lag = TRUE)
spat_fff4 = splm::spml(formula = fff4, data =mwi_bal, model = "error", effects ="tpfe",  
                         w = queenw, lag = TRUE)
spat_fff5 = splm::spml(formula = fff5, data =mwi_bal, model = "error", effects ="tpfe",  
                         w = queenw, lag = TRUE)
spat_fff2_nomig = splm::spml(formula = fff2_nomig, data =mwi_bal, model = "error", effects ="tpfe",  
                               w = queenw, lag = TRUE)
spat_fff3_nomig = splm::spml(formula = fff3_nomig, data =mwi_bal, model = "error", effects ="tpfe",  
                               w = queenw, lag = TRUE)
spat_fff4_nomig = splm::spml(formula = fff4_nomig, data =mwi_bal, model = "error", effects ="tpfe",  
                               w = queenw, lag = TRUE)
spat_fff5_nomig = splm::spml(formula = fff5_nomig, data =mwi_bal, model = "error", effects ="tpfe",  
                               w = queenw, lag = TRUE)





# AIC and BIC function for splm object #
#copied (and then edited) from this git repository https://github.com/rfsaldanha/ecoespacialunicamp/blob/master/OLD/AICsplm.R
# at the suggestion of this stackoverflow post: https://stackoverflow.com/questions/55838656/extract-aic-from-a-fixed-effect-spatial-panel-model-estimation-result

BICsplm = function(object, k=2){ 
  sp = summary(object)
  l = sp$logLik
  np = length(coef(sp))
  N = nrow(sp$model)
  bic = -2*l+log(N)*np
  names(bic) = "BIC"
  return(bic)
}

bics = c("withoutspatial" = BICsplm(wmod),"withspatial" = BICsplm(wmodr))
# the model w spatial random intercept is a better fit 

#save(bics) 



```

Using Queen contiguity because it looks like that's what's used by Sparks and Sparks and also by the county-level examples in this course that I referenced as a baseline before accounting for temporal correlation too https://crd230.github.io/lab8.html#Spatial_error_model

To account for both space and time, I use the splm package in R.

First I test the models using a subset of WI data.

The splm package requires a balanced dataset (ie all destinations must have the same years of available data). This requires throwing out some data :(

We stick with ML - includes random effects, more about modeling than estimation

```{r, WIonly}

cp = tidycensus::get_acs(geography = "county", year = 2019, variables = c(tpop = "B01003_001"), survey = "acs5", state = "WI", output = "wide", geometry = TRUE)

wisub = mnn %>% filter(substr(destid, 1, 2) == "55")

nyears = wisub %>% group_by(destid) %>% 
  count()

#there are two counties with 7 years of data only....
# is it better to remove the two counties or remove the 8th year....
# easier to remove the two counties because it turns out that they don't have the same 7 years of data 

wisub_bal = wisub %>% group_by(destid) %>% 
  filter(n()==8)

cpmnn = merge(cp, wisub_bal, by.x = "GEOID", by.y = "destid")


spsub= cpmnn %>% select(GEOID, geometry) %>% distinct()
queen = spdep::poly2nb(spsub, row.names = "GEOID", queen = T)
queenw = spdep::nb2listw(queen, style = "W", zero.policy = TRUE)

library(splm)
fm = rate_d1 ~ ft + rate_d0 + migterm


  
wmod = splm::spml(formula = fm, data = wisub_bal, model = "random", 
                  listw = queenw, lag = TRUE)

```

```{r, all counties}

cp = tidycensus::get_acs(geography = "county", year = 2019, variables = c(tpop = "B01003_001"), survey = "acs5", output = "wide", geometry = TRUE)

nyears = mnn %>% group_by(destid) %>% 
  count()

#there are many counties with fewer than 8 years of data, some with as few as 5 years.... 
# is it better to remove the counties or remove the years....
# easier to remove counties because not all counties have the same 5 years of data... 
#906 observations lost and 145 counties lost 


mnn_bal = mnn %>% group_by(destid) %>% 
  filter(n()==8)

cpmnn = merge(cp, mnn_bal, by.x = "GEOID", by.y = "destid")


spsub= cpmnn %>% select(GEOID, geometry) %>% distinct()
queen = spdep::poly2nb(spsub, row.names = "GEOID", queen = T)
queenw = spdep::nb2listw(queen, style = "W", zero.policy = TRUE)

library(splm)
fm = totrate_d1 ~ ft + totrate_d0 + migterm

allmod = splm::spml(formula = fm, data = mnn_bal, model = "random", 
                  listw = queenw, lag = TRUE)

```
